{"version":3,"sources":["Header.tsx","Footer.tsx","NavBar.tsx","articles/Cachegrind.tsx","App.tsx","serviceWorker.js","index.tsx"],"names":["styles","backgroundImage","Header","props","className","style","heading","subHeading","date","Footer","href","NavBar","type","data-toggle","data-target","id","to","Cachegrind","src","alt","App","basename","exact","path","component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.44ca899a.chunk.js","sourcesContent":["import React from 'react';\nimport {CSSProperties} from 'react';\n\nconst styles = {\n  backgroundImage: `url('images/home-bg.jpg')`\n} as CSSProperties\n\nfunction Header(props: {date: string, heading: string, subHeading: string}) {\n  return (\n    <header className=\"intro-header\" style={ styles }>\n      <div className=\"container\">\n        <div className=\"row\">\n          <div className=\"col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1\">\n            <div className=\"post-heading\">\n              <h1>{props.heading}</h1>\n              <h2 className=\"subheading\">{props.subHeading}</h2>\n              <span className=\"meta\">Posted on: {props.date}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    </header>\n  );\n}\n\nexport default Header;\n","import React from 'react';\n\nfunction Footer() {\n  return (\n    <footer>\n      <div className=\"container\">\n        <div className=\"row\">\n          <div className=\"col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1\">\n            <ul className=\"list-inline text-center\">\n              <li>\n                <a href=\"#\">\n                  <span className=\"fa-stack fa-lg\">\n                    <i className=\"fa fa-circle fa-stack-2x\"></i>\n                    <i className=\"fa fa-twitter fa-stack-1x fa-inverse\"></i>\n                  </span>\n                </a>\n              </li>\n              <li>\n                <a href=\"#\">\n                  <span className=\"fa-stack fa-lg\">\n                    <i className=\"fa fa-circle fa-stack-2x\"></i>\n                    <i className=\"fa fa-facebook fa-stack-1x fa-inverse\"></i>\n                  </span>\n                </a>\n              </li>\n              <li>\n                <a href=\"#\">\n                  <span className=\"fa-stack fa-lg\">\n                    <i className=\"fa fa-circle fa-stack-2x\"></i>\n                    <i className=\"fa fa-github fa-stack-1x fa-inverse\"></i>\n                  </span>\n                </a>\n              </li>\n            </ul>\n            <p className=\"copyright text-muted\">Copyright &copy; Michael Caisey 2020</p>\n          </div>\n        </div>\n      </div>\n    </footer>\n  );\n}\n\nexport default Footer;\n","import React from 'react';\nimport { Link } from \"react-router-dom\";\n\nfunction NavBar() {\n  return (\n    <nav className=\"navbar navbar-default navbar-custom navbar-fixed-top\">\n      <div className=\"container-fluid\">\n        <div className=\"navbar-header page-scroll\">\n          <button type=\"button\" className=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\">\n            <span className=\"sr-only\">Toggle navigation</span>\n            Menu <i className=\"fa fa-bars\"></i>\n          </button>\n          <a className=\"navbar-brand\" href=\"index.html\">Portfolio</a>\n        </div>\n\n        <div className=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\">\n          <ul className=\"nav navbar-nav navbar-right\">\n            <li><Link to=\"/\">Legacy Software</Link></li>\n          </ul>\n        </div>\n      </div>\n    </nav>\n  );\n}\n\nexport default NavBar;\n","import React from 'react';\n\nexport const heading = 'Xdebug Cachegrind to JSON'\nexport const subHeading = 'How to translate Cachegrind files into JSON with map and reduce functions'\nexport const date = 'May 18, 2020'\n\nfunction Cachegrind() {\n  return (\n    <article className=\"App-article\">\n      <h3>TL;DR</h3>\n      <p>To translate your Xdebug Cachegrind files into a JSON document, i.e. a graph of objects representing nodes and edges, do the following map and reduce commands from the root of this repository: <a href=\"https://github.com/mikecaisey/legacy-applications\">legacy applications</a></p>\n      <pre id=\"diagram-1\"># Map<br />$ cat assets/cachegrind.out.1588292840-_var_www_html_index_php | \\<br />node src/cachegrindr/map-to-js.js > file.js<br /><br /># Reduce<br />$ cat file.js src/cachegrindr/reduce-to-JSON.js | node > file.json<br /></pre>\n      <p className=\"diagram-text\">Fig 1: Command line example</p>\n      <p>Both operations could both be coded into one file (to couple them) but separation allows for greater flexibility. This demonstration Cachegrind profile is generated from a runtime WordPress.</p>\n      <h3>Introduction</h3>\n      <p>In this article it is assumed the reader has been made responsible for using Xdebug’s Cachegrind plugin to report on the performance of an application written in PHP. This is considered a legacy application or part of the performance test phase in a continuous integration pipeline. The PHP runtimes are dynamically profiled using the plugin and the output is many medium sized text files in Cachegrind format (~8M or 850K lines of text).</p>\n      <p>The problem is that the Cachegrind format isn’t easily understood by many if any at the company and the files have to be translated into a format that’s easily understood by the majority, in this case JSON format. The translation must be lossless in that it contains the time and memory complexity of the original profile and includes Callgrind’s call graph as well (Cachegrind is a subset of Callgrind, both part of the Valgrind toolset).</p>\n      <p>In this article I describe some hypotheses that failed, concluding with the simple program that succeeds. The solution uses a 2 step procedure using a map function and a reduce function. There's a brief discussion how this enables en masse translation using a MapReduce service.</p>\n      <h3>Cachegrind to JSON</h3>\n      <p>Initially, the Xdebug documentation presented some familiar tools: KCachegrind for Windows and Linux or a PHP Cachegrind interpreter. Neither of these fit the goal of translation to JSON and required too many external dependencies. They are more focussed on the presentation of the profile for isolated analysis. The solution presented here makes possible the fast processing of many Cachegrind profiles.</p>\n      <p><em>TDD failure: </em>Using the programmers rule of thumb and beginning by writing a failing test for the first step presented a problem. The problem is that the complexity of translation, once overcome, is a simple problem that doesn’t regress in the way that breaking a logic statement does. The tests end up mirroring the code in the program under test. The dropped tests can be seen in the git repository history. Sometimes things that are usually true need to be tried out and discarded so you can move on to something else. (TDD is still imperative to quality development and the prevention of regression).</p>\n      <p><em>RxJS failure: </em>You may reason that working with Cachegrind files are essentially cold streams. This is one of the situations where a stream based programming paradigm can be useful. RxJS is a fun library for working with events and streams but the simplicity of the solution (and the +13M addition to the project footprint) makes it superfluous. Node already has file streaming, regular expression matching and JSON pretty printing built in, no need for other libraries.</p>\n      <h3>The solution</h3>\n      <p>The epiphany comes from the fact that Cachegrind files use a declarative language that describes the events of a PHP application at runtime. They are generated by a context free grammar (given on the Valgrind website) and as such can be relied upon as having a start, recursive middle, and an end. Feeding the grammar (with minor changes) into a syntax diagramming tool results in a familiar image, similar to those on the JSON website.</p>\n      <pre id=\"diagram-2\">...<br />\n      positions: line<br />\n      events: Time Memory<br />\n      ...<br />\n      <br />\n      fl=(23) index.php<br />\n      fn=(1517) WP->main<br />\n      733 42 0<br />\n      cfl=(23)<br />\n      cfn=(607)<br />\n      calls=1 0 0<br />\n      734 45 0<br />\n      cfl=(23)<br />\n      cfn=(1516)<br />\n      calls=1 0 0<br />\n      735 256160 868120<br />\n      </pre>\n      <p className=\"diagram-text\">Fig 2: Example Cachegrind file</p>\n      <div className=\"diagram\" id=\"diagram-3\">\n      <img src={'images/image1.png'} alt='CostPosition' />\n      <img src={'images/image4.png'} alt='PositionName' />\n      <img src={'images/image3.png'} alt='CalledPosition' />\n      <img src={'images/image2.png'} alt='CallLine' />\n      </div>\n      <p className=\"diagram-text\">Fig 3: CostPosition, PositionName, CalledPosition, CalledLine</p>\n      <p>Knowing that Cachegrind is produced logically from its grammar you can describe the lines of the file in any other imperative language or code (e.g. Node.js or even pseudo code). Once mapped into the intermediate language the stream can be fed into the interpreter to build and manipulate objects in memory, then pretty-print them in JSON format. There is a bit of code for loading the file from disk and streaming it line by line. Then, there are Regex functions that match against the lines to produce the translated version. The only thing missing is a schema that the the whole process adheres to:</p>\n      <pre>{'// Schema'}<br />{'const data = { nodes: [], edges: [] }'}</pre>\n      <p className='diagram-text'>Fig 4: Target schema</p>\n      <p>It may occur to you that these are simply the steps of a map and reduce function pair common to the file processing model coined “MapReduce” by Google in 2004. They make the claim that many processing operations fit this design, however, a MapReduce service is definitely overkill for the processing of an 8M Cachegrind profile. The usage of the map reduce functions are shown in the TL;DR above.</p>\n      <h3>Takeaways</h3>\n      <p>MapReduce operations and machine learning are emerging default activities to perform on data, and are on the minds of companies these days. Running Xdebug profiles on our legacy applications isn’t that costly and we can process the output quickly into a data lake for review many times over. The Cachegrind files are segmented naturally into phrases that can be uniquely identified by a file and function composite key, which makes them good candidates for parallel processing in a MapReduce service, if done en masse.</p>\n      <p>The Cachegrind files are now in JSON format, ready to be used in node and edge diagrams and time/memory complexity analysis.</p>\n    </article>\n  );\n}\n\nexport default Cachegrind;\n","import React from 'react';\nimport { HashRouter, Route } from \"react-router-dom\";\n\nimport Header from './Header'\nimport Footer from './Footer'\nimport NavBar from './NavBar'\n\nimport Home from './articles/Home'\nimport Cachegrind from './articles/Cachegrind'\nimport { date, heading, subHeading } from './articles/Cachegrind'\n\nimport './App.css';\n\nfunction App() {\n  return (\n    <HashRouter basename='/portfolio'>\n      <NavBar />\n      <Header date={date} heading={heading} subHeading={subHeading} />\n      <div className=\"content container\">\n        <Route exact path=\"/\" component={Cachegrind}/>\n        <Route path=\"/legacy-software/cachegrind-to-JSON\" component={Cachegrind}/>\n      </div>\n      <Footer />\n    </HashRouter>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}